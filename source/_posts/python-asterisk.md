---
title: (转载)Python星号变量的特殊用法
tags: [python]
categories: programming
date: 2019-10-15
---

看到一篇非常好的讲解Python星号变量的用法，特转载之。
来自:晴刃(QingSword.COM)
原文连接:http://www.qingsword.com/qing/python-12.html

# 引言
在Python中，星号除了用于乘法数值运算和幂运算外，还有一种特殊的用法"在变量前添加单个星号或两个星号"，实现多参数的传入或变量的拆解，本文将详细介绍"星号参数"的用法。

# 0×1.什么是星号变量
最初，星号变量是用在函数的参数传递上的，在下面的实例中，单个星号代表这个位置接收任意多个非关键字参数，在函数的*b位置上将其转化成元组，而双星号代表这个位置接收任意多个关键字参数，在**b位置上将其转化成字典：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def one(a,*b):
    """a是一个普通传入参数，*b是一个非关键字星号参数"""
    print(b)
one(1,2,3,4,5,6)
#--------

def two(a=1,**b):
    """a是一个普通关键字参数，**b是一个关键字双星号参数"""
    print(b)
two(a=1,b=2,c=3,d=4,e=5,f=6)
#程序输出
(2, 3, 4, 5, 6)
{'b': 2, 'c': 3, 'e': 5, 'f': 6, 'd': 4}
#从输出中可以看到，第一个函数中，*b的位置可以传入任意多没有关键字的参数，*b会将这些传入参数转化成一个元组，下面的调用
one(1,2,3,4,5,6)
#传入one(a,*b)后，等价与
one(1,(2,3,4,5,6))

#第二个函数中，**b的位置可以接收任意多个关键字参数，下面的调用
two(a=1,b=2,c=3,d=4,e=5,f=6)
#传入one(a,*b)后，等价与
two(a=1,{'b': 2, 'c': 3, 'e': 5, 'f': 6, 'd': 4})
```
在了解了单星号和双星号的基本使用方法后，下面来看看他们的扩展用法。

# 0×2.单星号变量实例
单星号变量不仅仅能够用在函数的参数传递中，实际上对一个普通变量使用单星号前缀，能够将这个变量拆分成单个元素，请看下面的实例：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def one(*x):
    """输出传入的第一个参数"""
    print(x[0])
#--------
lst=["a","b","c","d"]
stri="www.qingsword.com"
one(stri,lst)
one(*lst)
one(*stri)
#程序输出
www.qingsword.com
a
w
#第一次调用one(stri,lst)，代入one(*x)后等价与
one((["a","b","c","d"],"www.qingsword.com"))
#第二次调用one(*lst)，代入one(*x)后等价与
one(("a","b","c","d"))
#第三次调用one(*stri)，代入one(*x)后等价与
one(("w","w","w",".","q","i","n","g","s","w","o","r","d",".","c","o","m"))
#如果在变量前面使用单星号，实际上是对变量的一次拆解操作，将变量中单独的元素拆解出来，然后依次传入one()函数，而传入one()函数后，one()函数会将这些传入的单个元素保存成一个元组，这就是为什么我们 print(x[0])能够提取第一个元素的原因
```
为了验证这一点，我们修改一下one()函数，如下：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def one(*x):
    """一个错误的实例，尝试修改传入的第一个参数值，引发异常"""
    print(x[0])
    x[0]="qingsword"
lst=["a","b","c","d"]
one(*lst)
#我们知道列表是可以更改的，我们将列表拆分后传入one()函数，尝试在函数内部更改第一个元素的值，结果触发了"TypeError"异常，大家可以自己尝试下，出现这种结果的原因上面已经说明，不论传入的参数的原始类型是什么，one(*x)在*x的位置接收这些传入的参数后，都会将其保存成"元组"，而元组是不能改变的
```
再来看几个实例：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def one(*x):
    """打印出传入参数"""
    for a in x:
        print(a)
lst=["abc",123,"www.qingsword.com"]
stri="abcd"
dect={1:"one",2:"two",3:"three"}
one(*lst)
one(*stri)
one(*dect)
#程序输出
abc
123
www.qingsword.com
a
b
c
d
1
2
3
#前面两次调用都很好理解，最后我们传入了一个字典元素，发现仅输出了字典元素的键，并没有包含值，实际上，单星号是无法读取到字典中的值的，永远只会读取到字典中的键，如果想读取到字典中的值，需要使用双星号
```
# 0×3.双星号变量实例
在第2小节的最后，我们使用单星号拆分了一个字典传递给函数，却只能得到字典的键，下面演示如何使用双星号来获得字典的值：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def one(**x):
    """将传入的关键字参数的值保存成元组输出"""
    print(x)
    b=()
    for a in x.values():
        b+=(a,)
    print(b)
dect={"one":1,"two":2,"three":3}
one(**dect)
#程序输出
{'three': 3, 'one': 1, 'two': 2}
(3, 1, 2)
#对一个字典使用双星号前缀，就相当于将其拆分成关键字参数的形式，**dect相当于将字典拆分成下面这种样子
one=1,two=2,three=3
#将上面这些关键字参数传入one(**x)，就等价与（还记得前面说的，双星号将接收到的所有关键字参数都保存成一个字典吧）
one({"one":1,"two":2,"three":3})
#既然是字典，那么字典中的所有方法都能使用，使用for循环遍历这个字典的值，添加到一个元组中，最后打印出这个元组
```
Ps：注意，使用这种方法将字典传入函数的时候，字典的键的命名要符合python变量的命名规则，通过上面的分析也不难看出，双星号会将字典首先转换成关键字参数的形式，就相当于使用字典中的键作为变量名，如果键不符合变量命名规则，则会抛出一个"TypeError"异常，大家可以尝试着颠倒一下上面字典中的键和值，使用数字作为键，看看会出现什么问题。

在一个函数的接收参数中，同时出现"非关键字参数（位置参数）"和"关键字参数"时，可以使用一个单星号来分隔这两种参数，例如：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def mix(a,b,*,x,y):
    """位置参数与关键字参数混合"""
    return a,b,x,y
#星号前面的a和b是位置参数，星号后面的x和y是关键字参数，调用mix()函数并传入参数时，关键字参数一定要使用"变量名=值"的形式传入数据，如果同位置参数一样传入数据，就会引发一个TypeError异常
print(mix(1,2,x=3,y=4))
#程序输出
(1, 2, 3, 4)
#在上面的mix函数中，如果位置参数与关键字参数之间已经存在了一个单星号位置参数，那么，这个参数后面的就都是关键字参数，也不需要再使用星号来分隔他们了，例如
#!/usr/bin/env python
#coding=utf-8
#--------
def mix(a,b,*c,x,y):
    """位置参数与关键字参数混合"""
    return a,b,c,x,y
#在*c的位置可以输入任意多个位置参数值
print(mix(1,2,3,4,5,x=6,y=7))
#程序输出
(1, 2, (3, 4, 5), 6, 7)
```
如果我们要在一个函数中包含多种参数的组合，必须遵守这样的顺序：位置参数（必选参数），默认参数，单星号参数或星号分隔符，关键字参数，双星号参数；请看下面的实例：
```python
#!/usr/bin/env python
#coding=utf-8
#--------
def mix(a,b=0,*c,x,**y):
    """位置参数与关键字参数混合"""
    return a,b,c,x,y
print(mix(1,2,3,4,5,x=6,y=7,z=8))
#程序输出
(1, 2, (3, 4, 5), 6, {'y': 7, 'z': 8})
```
